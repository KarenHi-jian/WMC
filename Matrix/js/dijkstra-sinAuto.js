// ===================================================================
// DIJKSTRA VOYAGER - Sistema de Algoritmos de Grafos
// Archivo: js/dijkstra-sinAuto.js
// ===================================================================

console.log("üöÄ Cargando Dijkstra Voyager...");

// Variables globales
let dijkstraApp = null;
let dijkstraGraph = null;
let selectedStart = null;
let selectedEnd = null;

// Verificar dependencias al cargar
document.addEventListener('DOMContentLoaded', function() {
  if (typeof cytoscape === 'undefined') {
    console.error('‚ùå Cytoscape no disponible. Aseg√∫rate de cargar la librer√≠a.');
    updateOutput('‚ùå Error: Cytoscape.js no cargado.\nPor favor recarga la p√°gina.');
  } else {
    console.log('‚úÖ Cytoscape disponible');
  }
});

// ===================================================================
// CLASE PRINCIPAL DIJKSTRA APP
// ===================================================================
class DijkstraApp {
  constructor() {
    this.container = document.getElementById('graph-container');
    if (!this.container) {
      console.error('‚ùå Graph container no encontrado');
      return;
    }
    
    // Limpiar contenedor
    this.container.innerHTML = '';
    
    // Crear instancia de Cytoscape
    this.cy = cytoscape({
      container: this.container,
      
      elements: [
        // Nodos iniciales
        { data: { id: 'node1' } },
        { data: { id: 'node2' } },
        { data: { id: 'node3' } },
        { data: { id: 'node4' } },
        // Aristas con pesos
        { data: { id: 'edge1', source: 'node1', target: 'node2', weight: 1 } },
        { data: { id: 'edge2', source: 'node2', target: 'node3', weight: 2 } },
        { data: { id: 'edge3', source: 'node1', target: 'node4', weight: 5 } },
        { data: { id: 'edge4', source: 'node4', target: 'node3', weight: 1 } }
      ],
      
      style: [
        {
          selector: 'node',
          style: {
            'background-color': '#00BFFF',
            'label': 'data(id)',
            'color': 'white',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '14px',
            'font-weight': 'bold',
            'width': 50,
            'height': 50,
            'border-width': 2,
            'border-color': '#87CEFA'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 4,
            'line-color': '#87CEFA',
            'target-arrow-color': '#87CEFA',
            'target-arrow-shape': 'triangle',
            'curve-style': 'bezier',
            'label': 'data(weight)',
            'color': 'white',
            'text-background-color': '#000',
            'text-background-opacity': 0.8,
            'font-size': '12px',
            'font-weight': 'bold'
          }
        },
        {
          selector: '.start-node',
          style: { 
            'background-color': '#00FF00',
            'border-color': '#00AA00',
            'border-width': 3
          }
        },
        {
          selector: '.end-node',
          style: { 
            'background-color': '#FF0000',
            'border-color': '#AA0000',
            'border-width': 3
          }
        },
        {
          selector: '.path-node',
          style: { 
            'background-color': '#FFFF00',
            'border-color': '#CCCC00',
            'border-width': 3
          }
        },
        {
          selector: '.path-edge',
          style: {
            'line-color': '#FF0000',
            'target-arrow-color': '#FF0000',
            'width': 6
          }
        }
      ],
      
      layout: { 
        name: 'circle', 
        radius: 150,
        padding: 30
      }
    });
    
    console.log('‚úÖ Grafo inicializado correctamente');
  }
  
  loadRandom() {
    // Eliminar elementos existentes
    this.cy.elements().remove();
    
    const nodeCount = Math.floor(Math.random() * 4) + 4; // 4-7 nodos
    const nodes = [];
    const edges = [];
    
    // Crear nodos
    for (let i = 1; i <= nodeCount; i++) {
      nodes.push({ data: { id: `node${i}` } });
    }
    
    // Crear conexiones b√°sicas para garantizar conectividad
    for (let i = 1; i < nodeCount; i++) {
      const weight = Math.floor(Math.random() * 5) + 1;
      edges.push({
        data: {
          id: `edge${i}-${i+1}`,
          source: `node${i}`,
          target: `node${i+1}`,
          weight: weight
        }
      });
    }
    
    // Agregar conexiones aleatorias adicionales
    for (let i = 1; i <= nodeCount; i++) {
      for (let j = i + 2; j <= nodeCount; j++) {
        if (Math.random() > 0.6) { // 40% probabilidad
          const weight = Math.floor(Math.random() * 8) + 1;
          edges.push({
            data: {
              id: `edge${i}-${j}`,
              source: `node${i}`,
              target: `node${j}`,
              weight: weight
            }
          });
        }
      }
    }
    
    // Agregar elementos al grafo
    this.cy.add([...nodes, ...edges]);
    
    // Aplicar layout
    this.cy.layout({ 
      name: 'circle', 
      radius: 140,
      padding: 30
    }).run();
    
    return { nodes: nodeCount, edges: edges.length };
  }
  
  reset() {
    // Limpiar clases de estilo
    this.cy.nodes().removeClass('start-node end-node path-node');
    this.cy.edges().removeClass('path-edge');
  }
  
  getStats() {
    const nodes = this.cy.nodes();
    const edges = this.cy.edges();
    
    return {
      nodeCount: nodes.length,
      edgeCount: edges.length,
      nodeIds: nodes.map(n => n.id()),
      connections: edges.map(e => ({
        source: e.source().id(),
        target: e.target().id(),
        weight: e.data('weight') || 1
      }))
    };
  }
}

// ===================================================================
// ALGORITMO DIJKSTRA - IMPLEMENTACI√ìN PROFESIONAL
// ===================================================================
function dijkstra(graph, startId, endId) {
  const nodes = graph.nodes();
  const edges = graph.edges();
  
  // Inicializaci√≥n de estructuras de datos
  const distances = {};
  const previous = {};
  const unvisited = new Set();
  
  // Inicializar distancias y conjunto de no visitados
  nodes.forEach(node => {
    const id = node.id();
    distances[id] = id === startId ? 0 : Infinity;
    previous[id] = null;
    unvisited.add(id);
  });
  
  // Log para seguimiento del algoritmo
  const log = [
    `üöÄ Iniciando algoritmo de Dijkstra`,
    `üìç Origen: ${startId}`,
    `üéØ Destino: ${endId}`,
    `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`,
    `üîß Algoritmo inicializado con ${nodes.length} nodos`,
    `üìä Distancias iniciales: ${JSON.stringify(distances)}`
  ];
  
  // Algoritmo principal
  while (unvisited.size > 0) {
    // Encontrar nodo no visitado con menor distancia
    let currentNode = null;
    let minDistance = Infinity;
    
    for (const nodeId of unvisited) {
      if (distances[nodeId] < minDistance) {
        minDistance = distances[nodeId];
        currentNode = nodeId;
      }
    }
    
    // Si no hay m√°s nodos alcanzables
    if (currentNode === null || distances[currentNode] === Infinity) {
      log.push(`‚ùå No hay m√°s nodos alcanzables desde ${startId}`);
      break;
    }
    
    // Marcar como visitado
    unvisited.delete(currentNode);
    log.push(`üîç Visitando nodo: ${currentNode} (distancia: ${distances[currentNode]})`);
    
    // Si llegamos al destino, podemos terminar
    if (currentNode === endId) {
      log.push(`‚úÖ ¬°Destino ${endId} alcanzado!`);
      break;
    }
    
    // Examinar todos los vecinos del nodo actual
    const neighbors = edges.filter(edge => 
      edge.source().id() === currentNode || edge.target().id() === currentNode
    );
    
    neighbors.forEach(edge => {
      // Determinar el vecino
      const neighborId = edge.source().id() === currentNode ? 
        edge.target().id() : edge.source().id();
      
      // Solo procesar si no ha sido visitado
      if (unvisited.has(neighborId)) {
        const weight = edge.data('weight') || 1;
        const newDistance = distances[currentNode] + weight;
        
        // Si encontramos un camino m√°s corto
        if (newDistance < distances[neighborId]) {
          distances[neighborId] = newDistance;
          previous[neighborId] = currentNode;
          log.push(`    üìä Actualizando ${neighborId}: nueva distancia ${newDistance} (arista peso: ${weight})`);
        }
      }
    });
    
    log.push(`    üó∫Ô∏è Estado actual: ${JSON.stringify(distances)}`);
  }
  
  // Reconstruir el camino m√°s corto
  const path = [];
  let current = endId;
  
  while (current !== null) {
    path.unshift(current);
    current = previous[current];
  }
  
  // Verificar si se encontr√≥ un camino v√°lido
  if (path[0] !== startId) {
    log.push(`‚ùå No existe camino de ${startId} a ${endId}`);
    return { path: [], distance: Infinity, log };
  }
  
  // Calcular nodos visitados
  const visitedNodes = [];
  nodes.forEach(node => {
    if (distances[node.id()] !== Infinity) {
      visitedNodes.push(node.id());
    }
  });
  
  // Agregar resultado final al log
  log.push(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
  log.push(`‚úÖ ¬°Camino m√°s corto encontrado!`);
  log.push(`üìè Distancia total: ${distances[endId]}`);
  log.push(`üõ§Ô∏è Camino √≥ptimo: ${path.join(' ‚Üí ')}`);
  log.push(`üëÅÔ∏è Nodos visitados: ${visitedNodes.join(', ')}`);
  log.push(`üéØ N√∫mero de saltos: ${path.length - 1}`);
  
  return { 
    path, 
    distance: distances[endId], 
    log, 
    visited: visitedNodes,
    allDistances: distances 
  };
}

// ===================================================================
// UTILIDADES
// ===================================================================
function updateOutput(message) {
  const output = document.getElementById('algorithm-output');
  if (output) {
    output.textContent = message;
  }
}

// ===================================================================
// FUNCIONES GLOBALES PARA LOS BOTONES HTML
// ===================================================================

window.initializeApp = function() {
  try {
    if (typeof cytoscape === 'undefined') {
      updateOutput('‚ùå Error: Cytoscape.js no est√° disponible.\nPor favor recarga la p√°gina.');
      return;
    }
    
    dijkstraApp = new DijkstraApp();
    dijkstraGraph = dijkstraApp.cy;
    
    const status = document.getElementById('app-status');
    if (status) {
      status.innerHTML = 'App-Status: Initialisiert ‚úÖ';
      status.style.color = '#00FF00';
    }
    
    updateOutput('üöÄ DIJKSTRA VOYAGER erfolgreich initialisiert!\n\n‚úÖ Graph mit 4 Knoten erstellt\n‚úÖ Cytoscape.js geladen\n‚úÖ Bereit f√ºr Pfadfindung!\n\nüí° N√§chste Schritte:\n1. Optional: "Zuf√§llige Daten" laden\n2. Start- und Zielknoten eingeben\n3. "Knoten ausw√§hlen" klicken\n4. Dijkstra-Algorithmus ausf√ºhren\n\nüìö Professionelle Implementierung aktiv');
    console.log('‚úÖ App inicializada correctamente');
  } catch (error) {
    console.error('‚ùå Error al inicializar:', error);
    updateOutput('‚ùå Error al inicializar: ' + error.message + '\n\nVerifique que todas las librer√≠as est√©n cargadas.');
  }
};

window.loadRandomData = function() {
  if (!dijkstraApp) {
    updateOutput('‚ùå App nicht initialisiert!\n\nBitte klicken Sie zuerst auf\n"App initialisieren"');
    return;
  }
  
  try {
    const result = dijkstraApp.loadRandom();
    selectedStart = null;
    selectedEnd = null;
    
    // Limpiar inputs
    const startInput = document.getElementById('start-node');
    const endInput = document.getElementById('end-node');
    if (startInput) startInput.value = '';
    if (endInput) endInput.value = '';
    
    updateOutput(`üé≤ Zuf√§lliger Graph erfolgreich geladen!\n\nüìä Statistiken:\n‚Ä¢ Knoten: ${result.nodes}\n‚Ä¢ Verbindungen: ${result.edges}\n‚Ä¢ Typ: Zuf√§llig generiert\n\nüí° Tipp:\nVerwenden Sie "Graph-Statistiken"\num verf√ºgbare Knoten zu sehen\n\n‚ö†Ô∏è Neue Knotenauswahl erforderlich`);
    console.log('‚úÖ Datos aleatorios cargados:', result);
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim Laden der Daten: ' + error.message);
  }
};

window.clearApp = function() {
  try {
    dijkstraApp = null;
    dijkstraGraph = null;
    selectedStart = null;
    selectedEnd = null;
    
    const container = document.getElementById('graph-container');
    if (container) {
      container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #87CEFA; font-size: 1.2em;">Klicken Sie auf "App initialisieren" um zu beginnen</div>';
    }
    
    const status = document.getElementById('app-status');
    if (status) {
      status.innerHTML = 'App-Status: Nicht initialisiert ‚ùå';
      status.style.color = '#FF0000';
    }
    
    // Limpiar inputs
    const startInput = document.getElementById('start-node');
    const endInput = document.getElementById('end-node');
    if (startInput) startInput.value = '';
    if (endInput) endInput.value = '';
    
    updateOutput('üóëÔ∏è App erfolgreich gel√∂scht\n\n‚úÖ Alle Daten zur√ºckgesetzt\n‚úÖ Speicher freigegeben\n‚úÖ Bereit f√ºr Neuinitialisierung\n\nüí° Klicken Sie auf "App initialisieren"\num neu zu beginnen');
    console.log('‚úÖ App limpiada correctamente');
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim L√∂schen: ' + error.message);
  }
};

window.selectNodesManually = function() {
  if (!dijkstraApp) {
    updateOutput('‚ùå App nicht initialisiert!\n\nBitte zuerst "App initialisieren" klicken');
    return;
  }
  
  const startInput = document.getElementById('start-node');
  const endInput = document.getElementById('end-node');
  
  if (!startInput || !endInput) {
    updateOutput('‚ùå Eingabefelder nicht gefunden\n\nBitte Seite neu laden');
    return;
  }
  
  const startId = startInput.value.trim();
  const endId = endInput.value.trim();
  
  if (!startId || !endId) {
    updateOutput('‚ùå Leere Eingabefelder!\n\nBitte geben Sie Start- und Zielknoten ein\n\nüí° Beispiel:\n‚Ä¢ Start-Knoten: node1\n‚Ä¢ Ziel-Knoten: node3\n\nTipp: Verwenden Sie "Graph-Statistiken"\num verf√ºgbare Knoten zu sehen');
    return;
  }
  
  const startNode = dijkstraGraph.$('#' + startId);
  const endNode = dijkstraGraph.$('#' + endId);
  
  if (startNode.length === 0) {
    updateOutput(`‚ùå Start-Knoten "${startId}" nicht gefunden!\n\nVerf√ºgbare Knoten anzeigen:\n‚Üí Klicken Sie "Graph-Statistiken"\n\nüí° Knoten-IDs sind case-sensitive`);
    return;
  }
  
  if (endNode.length === 0) {
    updateOutput(`‚ùå Ziel-Knoten "${endId}" nicht gefunden!\n\nVerf√ºgbare Knoten anzeigen:\n‚Üí Klicken Sie "Graph-Statistiken"\n\nüí° Knoten-IDs sind case-sensitive`);
    return;
  }
  
  if (startId === endId) {
    updateOutput('‚ùå Ung√ºltige Auswahl!\n\nStart- und Zielknoten m√ºssen\nunterschiedlich sein\n\nüí° W√§hlen Sie zwei verschiedene Knoten');
    return;
  }
  
  // Reset visual styles
  dijkstraApp.reset();
  
  // Marcar nodos seleccionados
  startNode.addClass('start-node');
  endNode.addClass('end-node');
  
  selectedStart = startId;
  selectedEnd = endId;
  
  updateOutput(`‚úÖ Knoten erfolgreich ausgew√§hlt!\n\nüü¢ Start-Knoten: ${startId}\nüî¥ Ziel-Knoten: ${endId}\n\nüöÄ System bereit f√ºr Dijkstra-Algorithmus!\n\nüí° N√§chster Schritt:\nKlicken Sie auf einen der Dijkstra-Buttons:\n‚Ä¢ "Dijkstra mit Logging" (detailliert)\n‚Ä¢ "Dijkstra stumm" (nur Ergebnis)`);
  console.log('‚úÖ Nodos seleccionados:', { start: startId, end: endId });
};

window.runDijkstraWithLogging = function() {
  if (!dijkstraApp || !selectedStart || !selectedEnd) {
    updateOutput('‚ùå Voraussetzungen nicht erf√ºllt!\n\nPr√ºfen Sie:\n‚úÖ App initialisiert?\n‚úÖ Start-Knoten eingegeben?\n‚úÖ Ziel-Knoten eingegeben?\n‚úÖ "Knoten ausw√§hlen" geklickt?\n\nDann: Dijkstra ausf√ºhren');
    return;
  }
  
  try {
    // Reset y marcar nodos
    dijkstraApp.reset();
    dijkstraGraph.$('#' + selectedStart).addClass('start-node');
    dijkstraGraph.$('#' + selectedEnd).addClass('end-node');
    
    // Ejecutar algoritmo
    const result = dijkstra(dijkstraGraph, selectedStart, selectedEnd);
    
    let output = `üìä DIJKSTRA MIT VOLLST√ÑNDIGEM LOGGING\n\n`;
    output += `üìç Start: ${selectedStart} ‚Üí üéØ Ziel: ${selectedEnd}\n`;
    output += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
    
    if (result.distance === Infinity) {
      output += `‚ùå KEIN PFAD GEFUNDEN!\n\n`;
      output += `Die Knoten ${selectedStart} und ${selectedEnd}\nsind nicht miteinander verbunden.\n\n`;
      output += `üí° L√∂sungsvorschl√§ge:\n`;
      output += `‚Ä¢ Andere Knoten ausw√§hlen\n`;
      output += `‚Ä¢ Zuf√§llige Daten laden\n`;
      output += `‚Ä¢ Graph-Statistiken pr√ºfen`;
    } else {
      output += `‚úÖ K√úRZESTER PFAD ERFOLGREICH GEFUNDEN!\n\n`;
      output += `üèÜ OPTIMALES ERGEBNIS:\n`;
      output += `üìè Gesamtdistanz: ${result.distance}\n`;
      output += `üõ§Ô∏è Optimaler Pfad: ${result.path.join(' ‚Üí ')}\n`;
      output += `üëÅÔ∏è Besuchte Knoten: ${result.visited.join(', ')}\n`;
      output += `üéØ Anzahl Hops: ${result.path.length - 1}\n`;
      output += `‚ö° Effizienz: ${((result.visited.length / dijkstraGraph.nodes().length) * 100).toFixed(1)}% Knoten besucht\n\n`;
      
      // Visualizar camino en el grafo
      for (let i = 0; i < result.path.length - 1; i++) {
        const edge = dijkstraGraph.edges().filter(edge => 
          (edge.source().id() === result.path[i] && edge.target().id() === result.path[i + 1]) ||
          (edge.source().id() === result.path[i + 1] && edge.target().id() === result.path[i])
        );
        edge.addClass('path-edge');
      }
      
      // Marcar nodos del camino (excluyendo start y end)
      result.path.slice(1, -1).forEach(nodeId => {
        dijkstraGraph.$('#' + nodeId).addClass('path-node');
      });
    }
    
    output += `\nüìã DETAILLIERTES ALGORITHMUS-LOG:\n`;
    output += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    result.log.forEach(logEntry => {
      output += logEntry + '\n';
    });
    
    updateOutput(output);
    console.log('‚úÖ Dijkstra con logging ejecutado:', result);
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim Ausf√ºhren von Dijkstra: ' + error.message);
  }
};

window.runDijkstraSilent = function() {
  if (!dijkstraApp || !selectedStart || !selectedEnd) {
    updateOutput('‚ùå Voraussetzungen nicht erf√ºllt!\n\nBen√∂tigt:\n1. App initialisieren\n2. Knoten ausw√§hlen\n3. Dijkstra ausf√ºhren');
    return;
  }
  
  try {
    // Reset y marcar nodos
    dijkstraApp.reset();
    dijkstraGraph.$('#' + selectedStart).addClass('start-node');
    dijkstraGraph.$('#' + selectedEnd).addClass('end-node');
    
    // Ejecutar algoritmo
    const result = dijkstra(dijkstraGraph, selectedStart, selectedEnd);
    
    let output = `üîá DIJKSTRA STUMM (NUR ERGEBNIS)\n\n`;
    output += `üìç Start: ${selectedStart} ‚Üí üéØ Ziel: ${selectedEnd}\n`;
    output += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
    
    if (result.distance === Infinity) {
      output += `‚ùå KEIN PFAD VERF√úGBAR\n\n`;
      output += `Verbindung zwischen ${selectedStart} und ${selectedEnd}\nnicht m√∂glich.\n\n`;
      output += `üí° Versuchen Sie andere Knoten oder\nladen Sie zuf√§llige Daten.`;
    } else {
      output += `‚úÖ PFADFINDUNG ERFOLGREICH\n\n`;
      output += `üèÜ ENDERGEBNIS:\n`;
      output += `üìè K√ºrzeste Distanz: ${result.distance}\n`;
      output += `üõ§Ô∏è Optimaler Pfad: ${result.path.join(' ‚Üí ')}\n`;
      output += `üéØ Anzahl Hops: ${result.path.length - 1}\n`;
      output += `üëÅÔ∏è Besuchte Knoten: ${result.visited.length} von ${dijkstraGraph.nodes().length}\n`;
      output += `‚ö° Algorithmus-Effizienz: ${((result.visited.length / dijkstraGraph.nodes().length) * 100).toFixed(1)}%\n\n`;
      output += `‚ú® Pfad visuell im Graph hervorgehoben`;
      
      // Visualizar camino
      for (let i = 0; i < result.path.length - 1; i++) {
        const edge = dijkstraGraph.edges().filter(edge => 
          (edge.source().id() === result.path[i] && edge.target().id() === result.path[i + 1]) ||
          (edge.source().id() === result.path[i + 1] && edge.target().id() === result.path[i])
        );
        edge.addClass('path-edge');
      }
      
      result.path.slice(1, -1).forEach(nodeId => {
        dijkstraGraph.$('#' + nodeId).addClass('path-node');
      });
    }
    
    updateOutput(output);
    console.log('‚úÖ Dijkstra silencioso ejecutado:', result);
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim Ausf√ºhren: ' + error.message);
  }
};

window.resetGraphManual = function() {
  if (!dijkstraApp) {
    updateOutput('‚ùå App nicht initialisiert!\n\nBitte zuerst "App initialisieren" klicken');
    return;
  }
  
  try {
    dijkstraApp.reset();
    selectedStart = null;
    selectedEnd = null;
    
    const startInput = document.getElementById('start-node');
    const endInput = document.getElementById('end-node');
    if (startInput) startInput.value = '';
    if (endInput) endInput.value = '';
    
    updateOutput('üîÑ Graph erfolgreich zur√ºckgesetzt!\n\n‚úÖ Alle visuellen Markierungen entfernt\n‚úÖ Knoten-Auswahl gel√∂scht\n‚úÖ Eingabefelder geleert\n‚úÖ Bereit f√ºr neue Auswahl\n\nüí° N√§chste Schritte:\n1. Start- und Zielknoten eingeben\n2. "Knoten ausw√§hlen" klicken\n3. Dijkstra-Algorithmus ausf√ºhren');
    console.log('‚úÖ Graph reseteado correctamente');
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim Zur√ºcksetzen: ' + error.message);
  }
};

window.showGraphStats = function() {
  if (!dijkstraApp) {
    updateOutput('‚ùå App nicht initialisiert!\n\nBitte zuerst "App initialisieren" klicken');
    return;
  }
  
  try {
    const stats = dijkstraApp.getStats();
    
    let output = `üìà DETAILLIERTE GRAPH-STATISTIKEN\n\n`;
    output += `üìä √úBERSICHT:\n`;
    output += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    output += `üî∏ Anzahl Knoten: ${stats.nodeCount}\n`;
    output += `üîó Anzahl Kanten: ${stats.edgeCount}\n`;
    output += `üåê Verbindungsdichte: ${((stats.edgeCount * 2) / (stats.nodeCount * (stats.nodeCount - 1)) * 100).toFixed(1)}%\n`;
    output += `üìê Durchschnittlicher Grad: ${(stats.edgeCount * 2 / stats.nodeCount).toFixed(1)}\n\n`;
    
    output += `üè∑Ô∏è VERF√úGBARE KNOTEN:\n`;
    output += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    stats.nodeIds.forEach(nodeId => {
      const degree = stats.connections.filter(c => c.source === nodeId || c.target === nodeId).length;
      const neighbors = stats.connections
        .filter(c => c.source === nodeId || c.target === nodeId)
        .map(c => c.source === nodeId ? c.target : c.source);
      output += `‚Ä¢ ${nodeId} (Grad: ${degree}) ‚Üí Verbunden mit: ${neighbors.join(', ')}\n`;
    });
    
    output += `\nüîó ALLE VERBINDUNGEN:\n`;
    output += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    stats.connections.forEach(connection => {
      output += `‚Ä¢ ${connection.source} ‚Üî ${connection.target} (Gewicht: ${connection.weight})\n`;
    });
    
    output += `\nüí° USAGE TIPPS:\n`;
    output += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    output += `‚Ä¢ Kopieren Sie Knoten-IDs f√ºr die Eingabe\n`;
    output += `‚Ä¢ H√∂heres Gewicht = l√§ngere Distanz\n`;
    output += `‚Ä¢ Alle Knoten sind √ºber Pfade erreichbar\n`;
    output += `‚Ä¢ Case-sensitive: "node1" ‚â† "Node1"`;
    
    updateOutput(output);
    console.log('‚úÖ Estad√≠sticas mostradas:', stats);
  } catch (error) {
    console.error('‚ùå Error:', error);
    updateOutput('‚ùå Error beim Anzeigen der Statistiken: ' + error.message);
  }
};

window.clearAlgorithmOutput = function() {
  updateOutput('DIJKSTRA VOYAGER wartet auf Befehle...\n\nüí° Verf√ºgbare Aktionen:\n‚Ä¢ App initialisieren\n‚Ä¢ Zuf√§llige Daten laden\n‚Ä¢ Graph-Statistiken anzeigen\n‚Ä¢ Knoten ausw√§hlen\n‚Ä¢ Dijkstra-Algorithmus ausf√ºhren');
};

// ===================================================================
// INICIALIZACI√ìN Y LOG
// ===================================================================
console.log("‚úÖ DIJKSTRA VOYAGER completamente cargado");
console.log("üéØ Funciones globales disponibles:", {
  initializeApp: typeof window.initializeApp,
  loadRandomData: typeof window.loadRandomData,
  selectNodesManually: typeof window.selectNodesManually,
  runDijkstraWithLogging: typeof window.runDijkstraWithLogging,
  runDijkstraSilent: typeof window.runDijkstraSilent,
  resetGraphManual: typeof window.resetGraphManual,
  showGraphStats: typeof window.showGraphStats,
  clearAlgorithmOutput: typeof window.clearAlgorithmOutput
});

console.log("üéâ ¬°Sistema completamente funcional! Haga clic en la pesta√±a 'Dijkstra' para comenzar.");

// Auto-verificaci√≥n al final de la carga
setTimeout(() => {
  if (typeof cytoscape !== 'undefined') {
    console.log('üü¢ Verificaci√≥n final: Todas las dependencias est√°n disponibles');
  } else {
    console.warn('üü° Advertencia: Cytoscape.js podr√≠a no estar disponible');
  }
}, 100);